import numpy as np
import gymnasium as gym
from gymnasium import spaces

x_min = 0
x_max = 500
y_min = 0
y_max = 500

# UAV
num_UAV = 3
H = 100
a_uav_max = 5
v_uav_max = 20
energyOfUAV = 20000 # J

# USER
num_user = 15
v_user_max = 10
v_user_min = 2
UAVmaxPower = 2

# nfz
obstacle_num = 2
obstacle_radius = np.array([40, 30])
obstacle_pos = np.zeros((obstacle_num, 3))
obstacle_pos[0, :] = np.array([150, 300, H])
obstacle_pos[1, :] = np.array([400, 200, H])
time_split = 10

# time slot
T = 200
Q = 200
delta = T / Q

sigma2 = 1e-11  # dBm noise
alpha_ku = 2
Rican_ku = 10
beta = 10 ** (-20 / 10)
carrier = 1
B = 1e7


class UAV_env:

    def __init__(self):
        self.x_min = x_min
        self.x_max = x_max
        self.y_min = y_min
        self.y_max = y_max
        # uav
        self.num_UAV = num_UAV
        self.H = H
        self.safety_distance = 3
        self.obstacle_distance = 2
        self.v_uav_max = v_uav_max
        self.UAV_v = np.zeros((num_UAV, 3))
        self.UAV_v_2D = np.zeros((self.num_UAV, 2))
        self.UAV_v_abs = np.linalg.norm(self.UAV_v, axis=1)
        self.a_uav_max = a_uav_max
        self.UAV_a = np.zeros((self.num_UAV, 3))
        self.UAV_a_2D = np.zeros((self.num_UAV, 2))
        self.UAV_a_abs = np.zeros(self.num_UAV)
        self.UAV_pos = np.zeros((self.num_UAV, 3))
        self.UAV_pos_2D = np.zeros((self.num_UAV, 2))

        self.UAV_pos[:, 0] = np.random.uniform(self.x_min + 10, self.x_max - 10, num_UAV).astype(float)  # x 坐标
        self.UAV_pos_2D[:, 0] = self.UAV_pos[:, 0]
        self.UAV_pos[:, 1] = np.random.uniform(self.y_min + 10, self.y_max - 10, num_UAV).astype(float)  # y 坐标
        self.UAV_pos_2D[:, 1] = self.UAV_pos[:, 1]
        self.UAV_pos[:, 2] = self.H

        self.UAV_previous_pos = np.copy(self.UAV_pos)
        self.UAV_battery = np.full(self.num_UAV, energyOfUAV)
        # user
        self.num_user = num_user
        self.v_user_min = v_user_min
        self.v_user_max = v_user_max
        self.User_v = np.zeros((self.num_user, 3))
        self.user_v_2D = np.zeros((self.num_user, 2))
        self.UAVmaxPower = UAVmaxPower
        self.P_alloc = np.zeros((self.num_user,self.num_UAV))

        self.offload_strategy = np.zeros((self.num_user, self.num_UAV))

        self.task_types = np.random.choice(["voice", "video", "sensor"], self.num_user)
        self.task_priority_mapping = {"voice": 0.2, "video": 0.4, "sensor": 0.3}
        self.task_priorities = np.array([self.task_priority_mapping[t] for t in self.task_types])

        self.T = T
        self.Q = Q
        self.delta = delta
        self.print_flag = True
        self.epsilon = 0

        # channel
        self.sigma2 = sigma2  # dBm
        self.alpha_ku = alpha_ku
        self.Rican_ku = Rican_ku
        self.beta = beta
        self.carrier = carrier
        self.B = B
        self.step_num = 0

        self.obstacle_num = obstacle_num
        self.obstacle_radius = obstacle_radius
        self.obstacle_pos = obstacle_pos
        self.time_split = time_split

        # ------------------MDP-----------------
        self.action_space = spaces.Box(self._get_low_action(),
                                       self._get_high_action(),
                                       shape=[self._get_a_dim()],
                                       dtype=np.float32
                                       )

        self.observation_space = spaces.Box(self._get_low_state(),
                                            self._get_high_state(),
                                            shape=[self._get_s_dim()],
                                            dtype=np.float32
                                            )


        self.user_pos = np.zeros((self.num_user, 3))
        self.user_pos_2D = np.zeros((self.num_user, 2))
        self.user_pos[:, 0] = np.random.uniform(self.x_min + 10, self.x_max - 10, num_user).astype(float)  # x 坐标
        self.user_pos_2D[:, 0] = self.user_pos[:, 0]
        self.user_pos[:, 1] = np.random.uniform(self.y_min + 10, self.y_max - 10, num_user).astype(float)  # y 坐标
        self.user_pos_2D[:, 1] = self.user_pos[:, 1]
        self.user_pos[:, 2] = 0
        self.alpha0 = np.zeros(self.num_user)

        self.d_ku = np.zeros((self.num_user, self.num_UAV))
        self.pathloss_ku = np.zeros((self.num_user, self.num_UAV))
        self.h_ku = np.zeros((self.num_user, self.num_UAV)) + 1j * np.zeros(
            (self.num_user, self.num_UAV))
        self.E_fly = np.zeros(self.num_UAV)
        self.update_channel()
        self.cum_rate = 0
        print("user_pos：", self.user_pos)


    def UAV_move(self):

        for i in range(self.num_UAV):

            self.UAV_pos[i, 0] = self.UAV_pos[i, 0] + self.UAV_v[i, 0] * self.delta + 0.5 * self.UAV_a[
                i, 0] * self.delta ** 2
            self.UAV_pos[i, 1] = self.UAV_pos[i, 1] + self.UAV_v[i, 1] * self.delta + 0.5 * self.UAV_a[
                i, 1] * self.delta ** 2
            self.UAV_pos[i, 2] = self.H

            self.UAV_v[i, 0] = self.UAV_v[i, 0] + self.UAV_a[i, 0] * self.delta
            self.UAV_v[i, 1] = self.UAV_v[i, 1] + self.UAV_a[i, 1] * self.delta

    def user_move(self):

        num_users = self.num_user
        dt = self.delta
        alpha = 0.85
        v_min = self.v_user_min
        v_max = self.v_user_max


        current_speeds = np.linalg.norm(self.user_v_2D, axis=1)
        current_directions = np.arctan2(self.user_v_2D[:, 1], self.user_v_2D[:, 0])

        w_noise = np.random.normal(0, 1, num_users)
        v_random = np.random.uniform(v_min, v_max, num_users)
        new_speeds = alpha * current_speeds + (1 - alpha) * v_random + np.sqrt(1 - alpha ** 2) * w_noise
        new_speeds = np.clip(new_speeds, v_min, v_max)
        new_directions = current_directions + np.random.normal(0, 0.1, num_users)

        new_vx = new_speeds * np.cos(new_directions)
        new_vy = new_speeds * np.sin(new_directions)

        new_x = self.user_pos_2D[:, 0] + new_vx * dt
        new_y = self.user_pos_2D[:, 1] + new_vy * dt

        # Boundary
        out_of_x = (new_x < 0) | (new_x > self.x_max)
        out_of_y = (new_y < 0) | (new_y > self.y_max)
        new_vx[out_of_x] *= -1
        new_vy[out_of_y] *= -1

        new_x = self.user_pos_2D[:, 0] + new_vx * dt
        new_y = self.user_pos_2D[:, 1] + new_vy * dt

        self.user_pos_2D[:, 0] = np.clip(new_x, 0, self.x_max)
        self.user_pos_2D[:, 1] = np.clip(new_y, 0, self.y_max)

        self.user_pos[:, :2] = self.user_pos_2D

        self.user_v_2D[:, 0] = new_vx
        self.user_v_2D[:, 1] = new_vy

    def _get_observation(self):

        state = np.concatenate([
            self.UAV_pos_2D.flatten(),
            self.UAV_v_2D.flatten(),
            self.UAV_battery.flatten(),
            self.user_pos_2D.flatten(),
            self.user_v_2D.flatten(),
            np.array([self.task_priorities]).flatten(),
        ])

        return self.norm_obs(state)

    def norm_obs(self, state):
        return (state - self.observation_space.low) / (self.observation_space.high - self.observation_space.low)


    def _get_low_state(self):
        low_v = -np.ones((self.num_UAV, 2)) * self.v_uav_max
        low_v_user = -np.ones((self.num_user, 2)) * self.v_user_max
        low_state = np.concatenate([
            np.array([self.x_min, self.y_min] * self.num_UAV),
            low_v.flatten(),
            np.zeros(self.num_UAV),
            np.zeros((self.num_user, 2)).flatten(),
            low_v_user.flatten(),
            [0] * self.num_user
        ])
        return low_state

    def _get_high_state(self):
        max_v = np.ones(((self.num_UAV, 2))) * self.v_uav_max
        max_user = np.ones((self.num_user, 2)) * self.x_max
        max_uav = np.ones((self.num_UAV, 2)) * self.x_max
        max_v_user = np.ones((self.num_user, 2)) * self.v_user_max
        high_state = np.concatenate([
            max_uav.flatten(),
            max_v.flatten(),
            np.ones(self.num_UAV) *energyOfUAV,
            max_user.flatten(),
            max_v_user.flatten(),
            [1] * self.num_user
        ])
        return high_state

    def _get_s_dim(self):
        return self._get_high_state().shape[0]


    def _get_low_action(self):

        low_a_uav = -np.ones((self.num_UAV, 2)) * self.a_uav_max
        return np.concatenate([
            low_a_uav.flatten(),
            np.zeros(self.num_user*self.num_UAV),
            np.zeros(self.num_user * self.num_UAV),
        ])

    # high
    def _get_high_action(self):

        max_a_uav = np.ones((self.num_UAV, 2)) * self.a_uav_max
        return np.concatenate([
            max_a_uav.flatten(),
            np.ones(self.num_user*self.num_UAV)*self.UAVmaxPower,
            np.ones(self.num_user * self.num_UAV),
        ])

    def _get_a_dim(self):
        return self._get_high_action().shape[0]

    def close(self):
        pass

    def translation_action(self, actions):
        act = actions
        ind = 0
        self.UAV_a_2D = np.reshape(act[ind:ind + self.num_UAV * 2], (self.num_UAV, 2))
        ind += self.num_UAV * 2
        self.P_alloc = np.reshape(act[ind:ind + self.num_UAV * self.num_user], (self.num_user, self.num_UAV))
        ind += self.num_user * self.num_UAV
        self.offload_strategy = np.reshape(act[ind:ind + self.num_UAV * self.num_user], (self.num_user, self.num_UAV))
        ind += self.num_UAV * self.num_user

        # ------- Redistribute alpha ---------
        for k in range(self.num_user):
            alpha_k = self.offload_strategy[k, :]
            id_choices = np.where(alpha_k == alpha_k.max())[0]
            id_choice = id_choices[0] if id_choices.size > 0 else np.random.choice(self.num_UAV)

            self.offload_strategy[k, :] = 0
            self.offload_strategy[k, id_choice] = 1
            #You can adjust alpha according to your own settings later

    def penalize(self, x, a, b):
        # print(f"Calling self.max with parameters: x={x}, a={a}, b={b}")
        k = self.max(0, (x - a) / b)
        return 2 - np.exp(-1 * k)

    def max(self, a, b):
        if a > b:
            return a
        else:
            return b

    def update_priority(self):
        self.task_priorities = np.array([self.task_priority_mapping[t] for t in self.task_types])


    def compute_sum_rate(self):

        sum_rate = np.zeros(self.num_user)
        for m in range(self.num_UAV):
            for k in range(self.num_user):
                sum_rate[k] +=self.offload_strategy[k,m] * (1+self.task_priorities[k]) * self.compute_rate(k, m)
        return sum_rate

    def compute_rate(self, k, m):
        s1 = np.abs(self.h_ku[k, m]) ** 2 * self.P_alloc[k, m]
        if np.isnan(s1):
            print(f"NaN detected in s1 for user {k}, setting s1 to 0.")
            s1 = 0

        other = [j for j in range(self.num_UAV) if j != m]
        h_other = self.h_ku[k, other]  # (N-1,)
        P_other = (self.P_alloc[:, other] * self.offload_strategy[:, other]).sum(axis=0) 
        interference = np.sum(np.abs(h_other) ** 2 * P_other) 

        SINR_k = s1 / (self.sigma2 + interference)

        rate = np.log2(1 + SINR_k)

        return rate

    def compute_distance(self, uav1, uav2):
        return np.linalg.norm(self.UAV_pos[uav1] - self.UAV_pos[uav2])


    def update_channel(self):
        '''channel user -> UAV'''

        for k in range(self.num_user):
            for m in range(self.num_UAV):
                self.d_ku[k, m] = np.sqrt(
                    (self.user_pos[k, 0] - self.UAV_pos[m, 0]) ** 2 +
                    (self.user_pos[k, 1] - self.UAV_pos[m, 1]) ** 2 +
                    (self.user_pos[k, 2] - self.UAV_pos[m, 2]) ** 2
                )
        self.pathloss_ku = np.sqrt(self.beta * self.d_ku ** (-self.alpha_ku))

        h_LOS_ku = np.zeros((self.num_user, self.num_UAV)) + 1j * np.zeros((self.num_user, self.num_UAV))

        for k in range(self.num_user):
            for m in range(self.num_UAV):
                h_LOS_ku[k, m] = np.exp(-1j * 2 * np.pi * self.d_ku[k, m] / self.carrier)

        h_NLOS_ku = np.sqrt(1 / 2) * (
                np.random.randn(self.num_user, self.num_UAV) + 1j * np.random.randn(self.num_user, self.num_UAV))

        self.h_ku = self.pathloss_ku.reshape(self.num_user, self.num_UAV) * np.ones(self.num_UAV) * (
                np.sqrt(self.Rican_ku / (1 + self.Rican_ku)) * h_LOS_ku + np.sqrt(1 / (1 + self.Rican_ku)) * h_NLOS_ku
        )


    def in_obstacle(self, pos):
        dis_1 = np.linalg.norm(pos - self.obstacle_pos[0, :])
        dis_2 = np.linalg.norm(pos - self.obstacle_pos[1, :])
        if dis_1 <= self.obstacle_radius[0] or dis_2 <= self.obstacle_radius[1]:
            return True
        else:
            return False

    def is_in_obstacle(self, m):

        start_pos = self.UAV_pos[m, :]

        v_initial = self.UAV_v[m, :]
        ts = self.delta / self.time_split
        for i in range(self.time_split + 1):
            if self.in_obstacle(start_pos):
                return True
            start_pos = start_pos + v_initial * ts + 0.5 * self.UAV_a * ts * ts
            v_initial = v_initial + self.UAV_a * ts
        return False


    def UAV_E_fly(self, pre_l_n, l_n, t_n):
        d_o = 0.6  # fuselage equivalent flat plate area;
        ro = 1.225  # air density in kg/m3;
        s = 0.05  # rotor solidity;
        G = 0.503  # Rotor disc area in m2;
        U_tip = 120  # tip seep of the rotor blade(m/s);
        v_o = 4.3  # mean rotor induced velocity in hover;
        omega = 300  # blade angular velocity in radians/second;
        R = 0.4  # rotor radius in meter;
        delta = 0.012  # profile drage coefficient;
        k = 0.1  # incremental correction factor to induced power;
        W = 20  # aircraft weight in newton;
        P0 = (delta / 8) * ro * s * G * (pow(omega, 3)) * (pow(R, 3))
        P1 = (1 + k) * (pow(W, (3 / 2)) / np.sqrt(2 * ro * G))
        P2 = 11.46

        x_pre = pre_l_n[0]
        y_pre = pre_l_n[1]
        z_pre = pre_l_n[2]
        x = l_n[0]
        y = l_n[1]
        z = l_n[2]

        d = np.sqrt((x_pre - x) ** 2 + (y_pre - y) ** 2)
        h = 0
        v_h = d / t_n
        v_v = h / t_n
        Energy_uav = t_n * P0 * (1 + 3 * np.power(v_h, 2) / np.power(U_tip, 2)) + t_n * (
                1 / 2) * d_o * ro * s * G * np.power(v_h, 3) + \
                     t_n * P1 * np.sqrt(np.sqrt(1 + np.power(v_h, 4) / (4 * np.power(v_o, 4))) - np.power(v_h, 2) / (
                2 * np.power(v_o, 2))) + P2 * v_v * t_n
        return Energy_uav

    def update_enery(self):

        self.E_fly = np.zeros(self.num_UAV)

        for m in range(self.num_UAV):
            self.E_fly[m] = self.UAV_E_fly(self.UAV_previous_pos[m, :], self.UAV_pos[m, :], self.delta)
            self.UAV_battery[m] = self.UAV_battery[m] - self.E_fly[m]

    def get_user_nfzs_reward(self):
        edge_reward = 0.0

        #Set the reward value according to the actual scenario

        return edge_reward

    def get_penalty(self):

        boundary_penalty = 0.0

        obstacle_penalty = 0.0

        collision_penalty = 0.0

        #Set various penalties and penalty values according to the actual scenario

        penalty =boundary_penalty + obstacle_penalty + collision_penalty

        print(f'boundary_penalty: {boundary_penalty:.2f} | '
              f'obstacle_penalty: {obstacle_penalty:.2f} | '
              f'collision_penalty: {collision_penalty:.2f} | ')

        return penalty


    def step(self,action):
        done = False
        self.step_num += 1
        reward = 0
        # index = 0
        self.UAV_previous_pos = np.copy(self.UAV_pos)
        self.translation_action(action)

        # update
        self.update_priority()
        self.user_move()
        self.UAV_move()
        self.update_channel()
        self.update_enery()

        # compute reward+penalty
        sum_rate = np.sum(self.compute_sum_rate())
        penal = self.get_penalty()
        edge_reward = self.get_user_nfzs_reward()

        reward += sum_rate
        reward -= penal
        reward += edge_reward

        for i in range(self.num_UAV):
            self.UAV_pos[i, 0] = np.clip(self.UAV_pos[i, 0], self.x_min, self.x_max)
            self.UAV_pos[i, 1] = np.clip(self.UAV_pos[i, 1], self.y_min, self.y_max)
            self.UAV_v[i, 0] = np.clip(self.UAV_v[i, 0], -self.v_uav_max, self.v_uav_max)
            self.UAV_v[i, 1] = np.clip(self.UAV_v[i, 1], -self.v_uav_max, self.v_uav_max)

        self.UAV_pos_2D[:, 0] = self.UAV_pos[:, 0]
        self.UAV_pos_2D[:, 1] = self.UAV_pos[:, 1]
        self.UAV_v_2D[:, 0] = self.UAV_v[:, 0]
        self.UAV_v_2D[:, 1] = self.UAV_v[:, 1]


        if self.step_num == self.Q:
            done = True
        if self.print_flag:
            np.set_printoptions(precision=8, suppress=True)
            print('uav_battery',self.UAV_battery)
            print("\n", self.step_num, " -- reward: ", reward, "\n")

        return self._get_observation(), reward, done, False, {}

    def seed(self, seed):
        np.random.seed(seed)

    def reset(self):
        self.step_num = 0

        self.UAV_pos[:, 0] = np.random.uniform(self.x_min + 10, self.x_max - 10, num_UAV).astype(float)  # x 坐标
        self.UAV_pos_2D[:, 0] = self.UAV_pos[:, 0]
        self.UAV_pos[:, 1] = np.random.uniform(self.y_min + 10, self.y_max - 10, num_UAV).astype(float)  # y 坐标
        self.UAV_pos_2D[:, 1] = self.UAV_pos[:, 1]
        self.UAV_pos[:, 2] = self.H
        self.UAV_previous_pos = np.copy(self.UAV_pos)
        self.UAV_battery = np.full(self.num_UAV, energyOfUAV)
        self.UAV_a = np.zeros((self.num_UAV, 3))
        self.UAV_a_2D = np.zeros((self.num_UAV, 2))
        self.UAV_a_abs = np.zeros(self.num_UAV)
        self.UAV_v = np.zeros((num_UAV, 3))
        self.UAV_v_2D = np.zeros((self.num_UAV, 2))
        self.UAV_v_abs = np.linalg.norm(self.UAV_v, axis=1)

        self.User_v = np.zeros((self.num_user, 3))
        self.user_v_2D = np.zeros((self.num_user, 2))
        self.P_alloc = np.zeros((self.num_user,self.num_UAV))
        self.offload_strategy = np.zeros((self.num_user, self.num_UAV))

        self.update_channel()
        self.E_fly = np.zeros(self.num_UAV)

        return self._get_observation(),{}
